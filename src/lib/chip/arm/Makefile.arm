 #
 # This file is part of RulOS, Ravenna Ultra-Low-Altitude Operating
 # System -- the free, open-source operating system for microcontrollers.
 #
 # Written by Jon Howell (jonh@jonh.net) and Jeremy Elson (jelson@gmail.com),
 # May 2009.
 #
 # This operating system is in the public domain.  Copyright is waived.
 # All source code is completely free to use by anyone for any purpose
 # with no restrictions whatsoever.
 #
 # For more information about the project, see: www.jonh.net/rulos
 #

# ARM-specific makefile came partially from seeing what LPCxpresso does,
# partially frmo the lpcopen-make project, which aims to also figure out
# the right makefile based on what LPCxpresso does:
# https://bitbucket.org/smartavionics/lpcopen-make/src

ARM_COMPILER_BINDIR := /usr/local/bin/gcc-arm-none-eabi-8-2018-q4-major/bin

PLATFORM_TARGET_LIST += arm-all
CLEAN_TARGET_LIST += arm-clean

ARM_SOURCES :=
ARM_INCLUDES :=

ARM_LIB_ROOT := $(ROCKET_ROOT)/lib/chip/arm

# Add platform-specific core sources to the all-platform sources
ARM_SOURCES += $(wildcard $(ARM_LIB_ROOT)/core/*.c)
ARM_INCLUDES += -I$(ARM_LIB_ROOT)

# Add platform-specific peripheral sources
ARM_SOURCES += $(foreach periph, $(PERIPHERALS), $(wildcard $(ARM_LIB_ROOT)/periph/$(periph)/*.c))

ARM_SOURCES += $(ALL_PLATFORM_SOURCES)
ARM_INCLUDES += $(ALL_PLATFORM_INCLUDES)

ARM_ARCHTARG := $(TARGET).arm-$(ARM_CHIP).$(BOARD)

# Compilation
ARM_OBJDIR = obj.$(ARM_ARCHTARG)
ARM_LIBNAME = rocket
ARM_LIB_FILE = $(ARM_OBJDIR)/lib$(ARM_LIBNAME).a
ARM_GCC_PREFIX = $(ARM_COMPILER_BINDIR)/arm-none-eabi

CURR_OBJDIR := $(ARM_OBJDIR)
-include $(foreach dir, $(sort $(dir $(ARM_SOURCES))), $(wildcard $(dir)/Makefile.extra))

###############################################################################
###############################################################################

STACK_SIZE ?= 0x400
HEAP_SIZE ?= 0x0

ifeq ($(ARM_CHIP),lpc1114-102)
ARM_CHIP_FAMILY := CHIP_LPC11CXX
ARM_FLASHK := 32
ARM_RAMK := 4
ARM_MX := M0
endif

ifeq ($(ARM_CHIP),lpc1115)
ARM_CHIP_FAMILY := CHIP_LPC11CXX
ARM_FLASHK := 64
ARM_RAMK := 8
ARM_MX := M0
endif

ifeq ($(ARM_CHIP),lpc11a14-301)
ARM_CHIP_FAMILY := CHIP_LPC11AXX
ARM_FLASHK := 32
ARM_RAMK := 8
ARM_MX := M0
endif

ifeq ($(ARM_CHIP),lpc11u67jbd48)
ARM_CHIP_FAMILY := CHIP_LPC11U6X
ARM_FLASHK := 128
ARM_RAMK := 16
ARM_MX := M0PLUS
endif

ifeq ($(ARM_CHIP),lpc1343)
ARM_CHIP_FAMILY := CHIP_LPC13XX
ARM_FLASHK := 32
ARM_RAMK := 8
ARM_MX := M3
endif

######################################################################

ifeq ($(ARM_CHIP_FAMILY),CHIP_LPC11CXX)
ARM_DRIVER_LIB := lpc_11uxx
endif

# Add startup file to source list, based on Cortex type type (M0, M0PLUS, M3)
ARM_SOURCES += $(ARM_LIB_ROOT)/startup/startup_ARMC$(ARM_MX).S

ARM_DRIVER_LIB_PATH := $(ARM_LIB_ROOT)/vendor_libraries/$(ARM_DRIVER_LIB)
ARM_CFLAGS += -I$(ARM_DRIVER_LIB_PATH)
ARM_SOURCES += $(wildcard $(ARM_DRIVER_LIB_PATH)/*.c)

######################################################################
# Set gcc arch flags according to Cortex CPU type

ifeq ($(ARM_MX),M0)
ARM_GCC_ARCH = armv6-m
ARM_GCC_CPU = cortex-m0
endif
ifeq ($(ARM_MX),M0PLUS)
ARM_GCC_ARCH = armv6-m
ARM_GCC_CPU = cortex-m0plus
endif
ifeq ($(ARM_MX),M3)
ARM_ARCH = armv7-m
ARM_CPU = cortex-m3
endif

ARM_CPUTYPE_FLAGS := -mcpu=$(ARM_GCC_CPU) -mthumb -march=$(ARM_GCC_ARCH)
ARM_CPUTYPE_FLAGS += -DCORE_$(ARM_MX)=1 -D$(ARM_CHIP_FAMILY)=1

#######################################################################
# Make sure ARM_CHIP_FAMILY is defined
.PHONY: arm-mcu-defined-check

arm-mcu-defined-check:
ifeq ($(ARM_CHIP),)
	@echo "ARM_CHIP must be defined in your local Makefile (lpc1114/102, for example)"
	@false
else
	@true
endif
ifeq ($(ARM_MX),)
	@echo "Unknown ARM_MX. Modify definitions in lib/chip/arm/Makefile.arm."
	@false
else
	@true
endif
ifeq ($(BOARD),)
	@echo "BOARD must be defined in your local Makefile (LPEM, GENERIC, etc)"
	@false
else
	@true
endif

## Options common to compile, link and assembly rules
ARM_COMMON_FLAGS = -Wall -Werror -DRULOS_ARM --specs=nano.specs
# Jeremy adds nano.specs because without it, we use ~1k of RAM on
# a section called impure_data, which is gcc internal stuff.
# See https://stackoverflow.com/questions/48711221/how-to-prevent-inclusion-of-c-library-destructors-and-atexit

## Compile options common for all C compilation units.
ARM_CFLAGS += $(ARM_COMMON_FLAGS) $(ALL_PLATFORM_CFLAGS)
ARM_CFLAGS += -I$(ARM_OBJDIR) $(ARM_INCLUDES)
#ARM_CFLAGS += -fpack-struct -fshort-enums
ARM_CFLAGS += -fdata-sections -ffunction-sections # Put all funcs/data in their own sections
ARM_CFLAGS += -MD -MP # -MT $(ARM_OBJDIR)/$(*F).o -MF $(ARM_OBJDIR)/$(@F).d 
ARM_CFLAGS += -std=gnu99 -Os -g
ARM_CFLAGS += $(ARM_CPUTYPE_FLAGS)
ARM_CFLAGS += -D__STACK_SIZE=$(STACK_SIZE) -D__HEAP_SIZE=$(HEAP_SIZE)
ARM_CFLAGS += -DBOARD_$(BOARD) # RULOS-specific board config
ARM_CFLAGS += $(EXTRA_ARM_CFLAGS)


## Linker flags
ARM_LD_SCRIPT ?= gcc_arm_$(ARM_FLASHK)k_$(ARM_RAMK)k.ld
ARM_LDFLAGS = $(ARM_COMMON_FLAGS)
ARM_LDFLAGS += -Wl,-Map=$(ARM_ARCHTARG).map,--cref -L$(ARM_OBJDIR) -l$(ARM_LIBNAME) 
ARM_LDFLAGS += -Wl,--gc-sections # Garbage-collect ununused functions
ARM_LDFLAGS += -static -L$(ARM_LIB_ROOT)/linker -T $(ARM_LD_SCRIPT)
ARM_LDFLAGS += -nostartfiles
ARM_LDFLAGS += $(ARM_CPUTYPE_FLAGS)
ARM_LDFLAGS += $(EXTRA_ARM_LDFLAGS)


## Intel Hex file production flags
HEX_FLASH_FLAGS = -R .eeprom -R .fuse -R .lock -R .signature

## Build
arm-all: arm-mcu-defined-check $(ARM_ARCHTARG).elf $(ARM_ARCHTARG).hex $(ARM_ARCHTARG).lss $(ARM_ARCHTARG).size

## Compile
$(ARM_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.c
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@
$(ARM_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.S
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@
$(ARM_OBJDIR)/app/%.o: %.c
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@


## Objects from each source file in the RULOS library
ARM_LIB_OBJECTS := $(patsubst $(ROCKET_ROOT)/lib/%.c,$(ARM_OBJDIR)/lib/%.o, $(ARM_SOURCES))
ARM_LIB_OBJECTS += $(patsubst $(ROCKET_ROOT)/lib/%.S,$(ARM_OBJDIR)/lib/%.o, $(ARM_SOURCES))

$(ARM_LIB_FILE): $(ARM_LIB_OBJECTS)
	rm -f $@
	$(ARM_GCC_PREFIX)-ar r $@ $(ARM_LIB_OBJECTS)

# TARGET_OBJECTS comes from the app's Makefile
ARM_TARGET_OBJECTS := $(patsubst %.o,$(ARM_OBJDIR)/app/%.o, $(TARGET_OBJECTS))

##Link
$(ARM_ARCHTARG).elf: $(ARM_LIB_FILE) $(ARM_TARGET_OBJECTS)
	$(ARM_GCC_PREFIX)-gcc $(ARM_TARGET_OBJECTS) $(ARM_LDFLAGS) -o $@

$(ARM_ARCHTARG).hex: $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-objcopy -O ihex $(HEX_FLASH_FLAGS)  $< $@

# removed dependency from arm-all to: $(ARM_ARCHTARG).eep
# Holdover from the AVR toolchain to generate eeprom file
#HEX_EEPROM_FLAGS = -j .eeprom
#HEX_EEPROM_FLAGS += --set-section-flags=.eeprom="alloc,load"
#HEX_EEPROM_FLAGS += --change-section-lma .eeprom=0 --no-change-warnings
#$(ARM_ARCHTARG).eep: $(ARM_ARCHTARG).elf
#	$(ARM_GCC_PREFIX)-objcopy $(HEX_EEPROM_FLAGS) -O ihex $< $@ || exit 0

$(ARM_ARCHTARG).lss: $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-objdump -h -S --syms $< > $@

.PHONY:
$(ARM_ARCHTARG).size: $(ARM_ARCHTARG).elf
	@echo
	$(ARM_GCC_PREFIX)-size $(ARM_ARCHTARG).elf

## Clean target
arm-clean:
	-rm -rf \
	    	$(ARM_OBJDIR) \
		$(ARM_ARCHTARG).elf \
		$(ARM_ARCHTARG).hex \
		$(ARM_ARCHTARG).eep \
		$(ARM_ARCHTARG).lss \
		$(ARM_ARCHTARG).map \


## Add automatically generated dependencies
DIR_LIST := $(sort $(dir $(ARM_LIB_OBJECTS) $(ARM_TARGET_OBJECTS)))
-include $(shell mkdir -p $(DIR_LIST)) $(foreach dir, $(DIR_LIST), $(wildcard $(dir)/*.d))

##############################################################################


arm-program: $(ARM_ARCHTARG).lss $(ARM_ARCHTARG).hex $(ARMCONFIG)
	sudo avrdude -c usbtiny $(ARMOPTS) -u -U flash:w:$(ARM_ARCHTARG).hex
