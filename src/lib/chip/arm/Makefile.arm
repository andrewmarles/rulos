#
# This file is part of RulOS, Ravenna Ultra-Low-Altitude Operating
# System -- the free, open-source operating system for microcontrollers.
#
# Written by Jon Howell (jonh@jonh.net) and Jeremy Elson (jelson@gmail.com),
# May 2009.
#
# This operating system is in the public domain.  Copyright is waived.
# All source code is completely free to use by anyone for any purpose
# with no restrictions whatsoever.
#
# For more information about the project, see: www.jonh.net/rulos
#

ARM_COMPILER_BINDIR := /usr/local/bin/gcc-arm-none-eabi-8-2018-q4-major/bin

# These are just "advisory" - so the linker can warn you if you don't
# have at least STACK_SIZE bytes available on the stack.
STACK_SIZE ?= 0x400
HEAP_SIZE ?= 0x0

PLATFORM_TARGET_LIST += arm-all
CLEAN_TARGET_LIST += arm-clean

ARM_SOURCES :=
ARM_INCLUDES :=

ARM_SOURCES += $(ALL_PLATFORM_SOURCES)
ARM_INCLUDES += $(ALL_PLATFORM_INCLUDES)

ARM_ARCHTARG := $(TARGET).arm-$(ARM_CHIP).$(BOARD)

# Compilation
ARM_OBJDIR = obj.$(ARM_ARCHTARG)
ARM_LIBNAME = rocket
ARM_LIB_FILE = $(ARM_OBJDIR)/lib$(ARM_LIBNAME).a
ARM_GCC_PREFIX = $(ARM_COMPILER_BINDIR)/arm-none-eabi

CURR_OBJDIR := $(ARM_OBJDIR)

###############################################################################
###############################################################################

ifneq ($(findstring chip-is-lpc,chip-is-$(ARM_CHIP)),)
ARM_SUBTYPE := lpc
endif

ifneq ($(findstring chip-is-stm32,chip-is-$(ARM_CHIP)),)
ARM_SUBTYPE := stm32
endif

######################################################################
# Add platform-specific core sources to the all-platform sources

ARM_LIB_ROOT := $(ROCKET_ROOT)/lib/chip/arm

# Add files common across all ARM platforms - both core and
# peripherals
ARM_SOURCES += $(wildcard $(ARM_LIB_ROOT)/common/core/*.c)
ARM_SOURCES += $(foreach periph, $(PERIPHERALS), $(wildcard $(ARM_LIB_ROOT)/common/periph/$(periph)/*.c))
ARM_INCLUDES += -I$(ARM_LIB_ROOT)/common

# Add the chip-specific support libraries
include $(ARM_LIB_ROOT)/$(ARM_SUBTYPE)/Makefile.arm-subtype

# Add the chip-specific core sources and peripherals
ARM_SOURCES += $(wildcard $(ARM_SUBLIB_ROOT)/core/*.c)
ARM_SOURCES += $(foreach periph, $(PERIPHERALS), $(wildcard $(ARM_SUBLIB_ROOT)/periph/$(periph)/*.c))
ARM_INCLUDES += -I$(ARM_SUBLIB_ROOT)

######################################################################
# Set gcc arch flags according to Cortex CPU type
# see $(GCC_ROOT)/../share/doc/gcc-arm-none-eabi/readme.txt

ifeq ($(ARM_MX),M0)
ARM_GCC_ARCH := armv6-m
ARM_GCC_CPU := cortex-m0
endif
ifeq ($(ARM_MX),M0PLUS)
ARM_GCC_ARCH := armv6-m
ARM_GCC_CPU := cortex-m0plus
endif
ifeq ($(ARM_MX),M3)
ARM_GCC_ARCH := armv7-m
ARM_GCC_CPU := cortex-m3
endif
ifeq ($(ARM_MX),M4)
ARM_GCC_ARCH = armv7e-m
ARM_GCC_CPU = cortex-m4
endif
ifeq ($(ARM_MX),M4F)
ARM_GCC_ARCH = armv7e-m
ARM_GCC_CPU = cortex-m4
ARM_CPUTYPE_FLAGS += -mfloat-abi=hard -mfpu=fpv4-sp-d16
endif

ARM_CPUTYPE_FLAGS += -mcpu=$(ARM_GCC_CPU) -mthumb -march=$(ARM_GCC_ARCH)
ARM_CPUTYPE_FLAGS += -DCORE_$(ARM_MX)=1 -D$(ARM_CHIP_FAMILY)=1

#######################################################################
# Make sure ARM_CHIP_FAMILY is defined
.PHONY: arm-mcu-defined-check

arm-mcu-defined-check:
ifeq ($(ARM_CHIP),)
	@echo "ARM_CHIP must be defined in your local Makefile (lpc1114/102, for example)"
	@false
else
	@true
endif
ifeq ($(ARM_SUBTYPE),)
	@echo "ARM_CHIP $(ARM_CHIP) doesn't start with a recognized manufacturer prefix"
	@false
else
	@true
endif
ifeq ($(ARM_FLASHK),)
	@echo "ARM_CHIP $(ARM_CHIP) doesn't seem to be recognized. Typo? Or new support needed?"
	@false
else
	@true
endif
ifeq ($(ARM_MX),)
	@echo "ARM_MX not defined. Modify definitions in lib/chip/arm/<subtype>/Makefile.arm-subtype."
	@false
else
	@true
endif
ifeq ($(BOARD),)
	@echo "BOARD must be defined in your local Makefile (LPEM, GENERIC, etc)"
	@false
else
	@true
endif

-include $(foreach dir, $(sort $(dir $(ARM_SOURCES))), $(wildcard $(dir)/Makefile.extra))

## Options common to compile, link and assembly rules
ARM_COMMON_FLAGS = -Wall -Werror -DRULOS_ARM --specs=nano.specs --specs=nosys.specs
# Jeremy adds nano.specs because without it, we use ~1k of RAM on
# a section called impure_data, which is gcc internal stuff.
# See https://stackoverflow.com/questions/48711221/how-to-prevent-inclusion-of-c-library-destructors-and-atexit

## Compile options common for all C compilation units.
ARM_CFLAGS += $(ARM_COMMON_FLAGS) $(ALL_PLATFORM_CFLAGS)
ARM_CFLAGS += -I$(ARM_OBJDIR) $(ARM_INCLUDES)
#ARM_CFLAGS += -fpack-struct -fshort-enums
ARM_CFLAGS += -fdata-sections -ffunction-sections # Put all funcs/data in their own sections
ARM_CFLAGS += -MD -MP # -MT $(ARM_OBJDIR)/$(*F).o -MF $(ARM_OBJDIR)/$(@F).d 
ARM_CFLAGS += -std=gnu99 -g
ARM_CFLAGS += -Os
ARM_CFLAGS += $(ARM_CPUTYPE_FLAGS)
ARM_CFLAGS += -D__STACK_SIZE=$(STACK_SIZE) -D__HEAP_SIZE=$(HEAP_SIZE)
ARM_CFLAGS += -DBOARD_$(BOARD) # RULOS-specific board config
ARM_CFLAGS += $(EXTRA_ARM_CFLAGS)


## Linker flags
ARM_LDFLAGS += $(ARM_COMMON_FLAGS)
ARM_LDFLAGS += -Wl,-Map=$(ARM_ARCHTARG).map,--cref -L$(ARM_OBJDIR) -l$(ARM_LIBNAME) 
ARM_LDFLAGS += -Wl,--gc-sections # Garbage-collect ununused functions
ARM_LDFLAGS += -static
ARM_LDFLAGS += -nostartfiles
ARM_LDFLAGS += $(ARM_CPUTYPE_FLAGS)
ARM_LDFLAGS += $(EXTRA_ARM_LDFLAGS)


## Intel Hex file production flags
HEX_FLASH_FLAGS = -R .eeprom -R .fuse -R .lock -R .signature

## Build
arm-all: arm-mcu-defined-check $(ARM_ARCHTARG).elf $(ARM_ARCHTARG).hex $(ARM_ARCHTARG).lss $(ARM_ARCHTARG).size

## Compile
$(ARM_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.c
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@
$(ARM_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.s
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@
$(ARM_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.S
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@
$(ARM_OBJDIR)/app/%.o: %.c
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@


## Objects from each source file in the RULOS library
ARM_LIB_OBJECTS :=
ARM_LIB_OBJECTS += $(patsubst $(ROCKET_ROOT)/lib/%.c,$(ARM_OBJDIR)/lib/%.o, $(filter $(ROCKET_ROOT)/lib/%.c,$(ARM_SOURCES)))
ARM_LIB_OBJECTS += $(patsubst $(ROCKET_ROOT)/lib/%.s,$(ARM_OBJDIR)/lib/%.o, $(filter $(ROCKET_ROOT)/lib/%.s,$(ARM_SOURCES)))
ARM_LIB_OBJECTS += $(patsubst $(ROCKET_ROOT)/lib/%.S,$(ARM_OBJDIR)/lib/%.o, $(filter $(ROCKET_ROOT)/lib/%.S,$(ARM_SOURCES)))

$(ARM_LIB_FILE): $(ARM_LIB_OBJECTS)
	rm -f $@
	$(ARM_GCC_PREFIX)-ar r $@ $(ARM_LIB_OBJECTS)

# TARGET_OBJECTS comes from the app's Makefile
ARM_TARGET_OBJECTS := $(patsubst %.o,$(ARM_OBJDIR)/app/%.o, $(TARGET_OBJECTS))

##Link
$(ARM_ARCHTARG).elf: $(ARM_LIB_FILE) $(ARM_TARGET_OBJECTS)
	$(ARM_GCC_PREFIX)-gcc $(ARM_TARGET_OBJECTS) $(ARM_LDFLAGS) -o $@

$(ARM_ARCHTARG).hex: $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-objcopy -O ihex $(HEX_FLASH_FLAGS)  $< $@

# removed dependency from arm-all to: $(ARM_ARCHTARG).eep
# Holdover from the AVR toolchain to generate eeprom file
#HEX_EEPROM_FLAGS = -j .eeprom
#HEX_EEPROM_FLAGS += --set-section-flags=.eeprom="alloc,load"
#HEX_EEPROM_FLAGS += --change-section-lma .eeprom=0 --no-change-warnings
#$(ARM_ARCHTARG).eep: $(ARM_ARCHTARG).elf
#	$(ARM_GCC_PREFIX)-objcopy $(HEX_EEPROM_FLAGS) -O ihex $< $@ || exit 0

$(ARM_ARCHTARG).lss: $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-objdump -h -S --syms $< > $@

.PHONY:
$(ARM_ARCHTARG).size: $(ARM_ARCHTARG).elf
	@echo
	$(ARM_GCC_PREFIX)-size $(ARM_ARCHTARG).elf

## Clean target
arm-clean:
	-rm -rf \
	    	$(ARM_OBJDIR) \
		$(ARM_ARCHTARG).elf \
		$(ARM_ARCHTARG).hex \
		$(ARM_ARCHTARG).eep \
		$(ARM_ARCHTARG).lss \
		$(ARM_ARCHTARG).map \


## Add automatically generated dependencies
DIR_LIST := $(sort $(dir $(ARM_LIB_OBJECTS) $(ARM_TARGET_OBJECTS)))
-include $(shell mkdir -p $(DIR_LIST)) $(foreach dir, $(DIR_LIST), $(wildcard $(dir)/*.d))

