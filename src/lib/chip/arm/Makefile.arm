 #
 # This file is part of RulOS, Ravenna Ultra-Low-Altitude Operating
 # System -- the free, open-source operating system for microcontrollers.
 #
 # Written by Jon Howell (jonh@jonh.net) and Jeremy Elson (jelson@gmail.com),
 # May 2009.
 #
 # This operating system is in the public domain.  Copyright is waived.
 # All source code is completely free to use by anyone for any purpose
 # with no restrictions whatsoever.
 #
 # For more information about the project, see: www.jonh.net/rulos
 #

# ARM-specific makefile came partially from seeing what LPCxpresso does,
# partially frmo the lpcopen-make project, which aims to also figure out
# the right makefile based on what LPCxpresso does:
# https://bitbucket.org/smartavionics/lpcopen-make/src

ARM_COMPILER_BINDIR := /usr/local/bin/gcc-arm-none-eabi-8-2018-q4-major/bin

PLATFORM_TARGET_LIST += arm-all
CLEAN_TARGET_LIST += arm-clean

ARM_SOURCES :=
ARM_INCLUDES :=

ARM_LIB_ROOT := $(ROCKET_ROOT)/lib/chip/arm

# Add platform-specific core sources to the all-platform sources
ARM_SOURCES += $(wildcard $(ARM_LIB_ROOT)/core/*.c)
ARM_INCLUDES += -I$(ARM_LIB_ROOT)

# Add platform-specific peripheral sources
ARM_SOURCES += $(foreach periph, $(PERIPHERALS), $(wildcard $(ARM_LIB_ROOT)/periph/$(periph)/*.c))

ARM_SOURCES += $(ALL_PLATFORM_SOURCES)
ARM_INCLUDES += $(ALL_PLATFORM_INCLUDES)

ARM_ARCHTARG := $(TARGET).arm-$(ARM_CHIP_FAMILY).$(BOARD)

# Compilation
ARM_OBJDIR = obj.$(ARM_ARCHTARG).$(BOARD)
ARM_LIBNAME = rocket
ARM_LIB_FILE = $(ARM_OBJDIR)/lib$(ARM_LIBNAME).a
ARM_GCC_PREFIX = $(ARM_COMPILER_BINDIR)/arm-none-eabi

CURR_OBJDIR := $(ARM_OBJDIR)
-include $(foreach dir, $(sort $(dir $(ARM_SOURCES))), $(wildcard $(dir)/../Makefile.extra))

#####################################################################################
#####################################################################################

STACK_SIZE ?= 0x200
HEAP_SIZE ?= 0x400

ifeq ($(ARM_CHIP_FAMILY),11xx)
ARM_ARCH = armv6-m
ARM_CPU = cortex-m0
ARM_MX = M0
ARM_CHIP ?= CHIP_LPC11CXX
ARM_FLASHK ?= 32
ARM_RAMK ?= 4
ARM_STARTUP ?= $(ARM_OBJDIR)/lib/chip/arm/startup/startup_ARMC$(ARM_MX).o
ARM_SOURCES += $(wildcard $(ARM_LIB_ROOT)/lpc_chip_11cxx_lib/*.c)
ARM_INCLUDES += -I$(ARM_LIB_ROOT)/lpc_chip_11cxx_lib -I$(ARM_LIB_ROOT)/core
endif

ifeq ($(ARM_CHIP_FAMILY),13xx)
ARM_ARCH = armv7-m
ARM_CPU = cortex-m3
ARM_MX = M3
ARM_CHIP ?= CHIP_LPC1343
ifeq ($(ARM_CHIP),CHIP_LPC1347)
ARM_FLASHK ?= 64
ARM_RAMK ?= 8
endif
ARM_FLASHK ?= 32
ARM_RAMK ?= 8
endif

ifeq ($(ARM_CHIP_FAMILY),17xx_40xx)
ARM_ARCH = armv7-m
ARM_CPU = cortex-m3
ARM_MX = M3
ARM_CHIP ?= CHIP_LPC175X_6X
ARM_FLASHK ?= 512
ARM_RAMK ?= 64
endif

ARM_CORE = CORE_$(ARM_MX)

## Options common to compile, link and assembly rules
ARM_COMMON_FLAGS = -Wall -Werror -DRULOS_ARM --specs=nano.specs
# Jeremy adds nano.specs because without it, we use ~1k of RAM on
# a section called impure_data, which is gcc internal stuff.
# See https://stackoverflow.com/questions/48711221/how-to-prevent-inclusion-of-c-library-destructors-and-atexit

## Compile options common for all C compilation units.
ARM_CFLAGS = $(ARM_COMMON_FLAGS)
ARM_CFLAGS += -I$(ARM_OBJDIR) $(ARM_INCLUDES)
ARM_CFLAGS += -D__STACK_SIZE=$(STACK_SIZE) -D__HEAP_SIZE=$(HEAP_SIZE)
ARM_CFLAGS += -fno-strict-aliasing -funsigned-bitfields -fpack-struct -fshort-enums
ARM_CFLAGS += -fdata-sections -ffunction-sections # Put all funcs/data in their own sections
ARM_CFLAGS += -MD -MP # -MT $(ARM_OBJDIR)/$(*F).o -MF $(ARM_OBJDIR)/$(@F).d 
ARM_CFLAGS += -std=gnu99 -Os -g
ARM_CFLAGS += -mcpu=$(ARM_CPU) -mthumb -march=$(ARM_ARCH) -D$(ARM_CORE)=1 -D$(ARM_CHIP)=1 -DBOARD_$(BOARD)
ARM_CFLAGS += $(EXTRA_ARM_CFLAGS)


## Linker flags
ARM_LD_SCRIPT ?= gcc_arm_$(ARM_FLASHK)k_$(ARM_RAMK)k.ld -L$(ARM_LIB_ROOT)/linker
ARM_LDFLAGS = $(ARM_COMMON_FLAGS)
ARM_LDFLAGS += -Wl,-Map=$(ARM_ARCHTARG).map,--cref -L$(ARM_OBJDIR) -l$(ARM_LIBNAME) 
ARM_LDFLAGS += -Wl,--gc-sections # Garbage-collect ununused functions
ARM_LDFLAGS += -lc -lm -static -T $(ARM_LD_SCRIPT)
ARM_LDFLAGS += $(EXTRA_ARM_LDFLAGS)


## Intel Hex file production flags
HEX_FLASH_FLAGS = -R .eeprom -R .fuse -R .lock -R .signature

HEX_EEPROM_FLAGS = -j .eeprom
HEX_EEPROM_FLAGS += --set-section-flags=.eeprom="alloc,load"
HEX_EEPROM_FLAGS += --change-section-lma .eeprom=0 --no-change-warnings

# Make sure ARM_CHIP_FAMILY is defined
.PHONY: mcu-defined-check

arm-mcu-defined-check:
ifeq ($(ARM_CHIP_FAMILY),)
	@echo "ARM_CHIP_FAMILY must be defined in your local Makefile (11xx, 13xx)"
	@false
else
	@true
endif
ifeq ($(BOARD),)
	@echo "BOARD must be defined in your local Makefile (PCB10, PCB11, CUSTOM)"
	@false
else
	@true
endif


## Build
arm-all: arm-mcu-defined-check $(ARM_ARCHTARG).elf $(ARM_ARCHTARG).hex $(ARM_ARCHTARG).eep $(ARM_ARCHTARG).lss $(ARM_ARCHTARG).size

## Compile
$(ARM_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.c
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@
$(ARM_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.S
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@
$(ARM_OBJDIR)/app/%.o: %.c
	$(ARM_GCC_PREFIX)-gcc $(ARM_CFLAGS) -c $< -o $@


## Objects that must be built in order to link.
ARM_LIB_OBJECTS := $(patsubst $(ROCKET_ROOT)/lib/%.c,$(ARM_OBJDIR)/lib/%.o, $(ARM_SOURCES))

$(ARM_LIB_FILE): $(ARM_LIB_OBJECTS)
	rm -f $@
	$(ARM_GCC_PREFIX)-ar r $@ $(ARM_LIB_OBJECTS)

# TARGET_OBJECTS comes from the app's Makefile
ARM_TARGET_OBJECTS := $(patsubst %.o,$(ARM_OBJDIR)/app/%.o, $(TARGET_OBJECTS))
ARM_TARGET_OBJECTS += $(ARM_STARTUP)

##Link
$(ARM_ARCHTARG).elf: $(ARM_LIB_FILE) $(ARM_TARGET_OBJECTS)
	$(ARM_GCC_PREFIX)-gcc $(ARM_TARGET_OBJECTS) $(ARM_LDFLAGS) -o $@

$(ARM_ARCHTARG).hex: $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-objcopy -O ihex $(HEX_FLASH_FLAGS)  $< $@

$(ARM_ARCHTARG).eep: $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-objcopy $(HEX_EEPROM_FLAGS) -O ihex $< $@ || exit 0

$(ARM_ARCHTARG).lss: $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-objdump -h -S --syms $< > $@

.PHONY:
$(ARM_ARCHTARG).size: $(ARM_ARCHTARG).elf
	@echo
#	@avr-size -C --mcu=${MCU} $(ARM_ARCHTARG).elf
	$(ARM_GCC_PREFIX)-size $(ARM_ARCHTARG).elf

## Clean target
arm-clean:
	-rm -rf \
	    	$(ARM_OBJDIR) \
		$(ARM_ARCHTARG).elf \
		$(ARM_ARCHTARG).hex \
		$(ARM_ARCHTARG).eep \
		$(ARM_ARCHTARG).lss \
		$(ARM_ARCHTARG).map \


## Add automatically generated dependencies
DIR_LIST := $(sort $(dir $(ARM_LIB_OBJECTS) $(ARM_TARGET_OBJECTS)))
-include $(shell mkdir -p $(DIR_LIST)) $(foreach dir, $(DIR_LIST), $(wildcard $(dir)/*.d))

##############################################################################


arm-program: $(ARM_ARCHTARG).lss $(ARM_ARCHTARG).hex $(ARMCONFIG)
	sudo avrdude -c usbtiny $(ARMOPTS) -u -U flash:w:$(ARM_ARCHTARG).hex

