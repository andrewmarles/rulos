 #
 # This file is part of RulOS, Ravenna Ultra-Low-Altitude Operating
 # System -- the free, open-source operating system for microcontrollers.
 #
 # Written by Jon Howell (jonh@jonh.net) and Jeremy Elson (jelson@gmail.com),
 # May 2009.
 #
 # This operating system is in the public domain.  Copyright is waived.
 # All source code is completely free to use by anyone for any purpose
 # with no restrictions whatsoever.
 #
 # For more information about the project, see: www.jonh.net/rulos
 #


PLATFORM_TARGET_LIST += avr-all
CLEAN_TARGET_LIST += avr-clean

AVR_SOURCES :=
AVR_INCLUDES := 

AVR_LIB_ROOT := $(ROCKET_ROOT)/lib/chip/avr

# Add platform-specific core sources to the all-platform sources
AVR_SOURCES += $(wildcard $(AVR_LIB_ROOT)/core/*.c)
AVR_INCLUDES += -I$(AVR_LIB_ROOT)

# Add platform-specific peripheral sources
AVR_SOURCES += $(foreach periph, $(PERIPHERALS), $(wildcard $(AVR_LIB_ROOT)/periph/$(periph)/*.c))

AVR_SOURCES += $(ALL_PLATFORM_SOURCES)
AVR_INCLUDES += $(ALL_PLATFORM_INCLUDES)

AVR_ARCHTARG := $(TARGET).$(MCU).$(BOARD)

# Compilation
AVR_OBJDIR = obj.avr.$(MCU).$(BOARD)
AVR_LIBNAME = rocket
AVR_LIB_FILE = $(AVR_OBJDIR)/lib$(AVR_LIBNAME).a
CC = avr-gcc

CURR_OBJDIR := $(AVR_OBJDIR)
-include $(foreach dir, $(sort $(dir $(AVR_SOURCES))), $(wildcard $(dir)/Makefile.extra))

## Options common to compile, link and assembly rules
AVR_COMMON_FLAGS = -Wall -Werror -mmcu=$(MCU) -DRULOS_AVR

## Compile options common for all C compilation units.
AVR_CFLAGS = $(ALL_PLATFORM_CFLAGS) $(AVR_COMMON_FLAGS)
AVR_CFLAGS += -g -Wall -Werror -I$(AVR_OBJDIR) $(AVR_INCLUDES)
AVR_CFLAGS += -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
AVR_CFLAGS += -fdata-sections -ffunction-sections # Put all funcs/data in their own sections
AVR_CFLAGS += -MD -MP # -MT $(AVR_OBJDIR)/$(*F).o -MF $(AVR_OBJDIR)/$(@F).d 
AVR_CFLAGS += -gdwarf-2 -std=gnu99 -Os 
AVR_CFLAGS += -DMCU$(MCU)=1 -DBOARD_$(BOARD)
AVR_CFLAGS += $(EXTRA_AVR_CFLAGS)


## Assembly specific flags
ASMFLAGS = $(AVR_COMMON_FLAGS)
ASMFLAGS += $(AVR_CFLAGS)
ASMFLAGS += -x assembler-with-cpp -Wa,-gdwarf2

## Linker flags
AVR_LDFLAGS = $(AVR_COMMON_FLAGS)
AVR_LDFLAGS +=  -Wl,-Map=$(AVR_ARCHTARG).map -L$(AVR_OBJDIR) -l$(AVR_LIBNAME) 
AVR_LDFLAGS += -Wl,--gc-sections # Garbage-collect ununused functions
AVR_LDFLAGS += $(EXTRA_AVR_LDFLAGS)


## Intel Hex file production flags
HEX_FLASH_FLAGS = -R .eeprom -R .fuse -R .lock -R .signature

HEX_EEPROM_FLAGS = -j .eeprom
HEX_EEPROM_FLAGS += --set-section-flags=.eeprom="alloc,load"
HEX_EEPROM_FLAGS += --change-section-lma .eeprom=0 --no-change-warnings

# Make sure MCU is defined
.PHONY: mcu-defined-check

mcu-defined-check:
ifeq ($(MCU),)
	@echo "MCU must be defined in your local Makefile (atmega8, atmega328p)"
	@false
else
	@true
endif
ifeq ($(BOARD),)
	@echo "BOARD must be defined in your local Makefile (PCB10, PCB11, CUSTOM)"
	@false
else
	@true
endif

## Build
avr-all: mcu-defined-check $(AVR_ARCHTARG).elf $(AVR_ARCHTARG).hex $(AVR_ARCHTARG).eep $(AVR_ARCHTARG).lss $(AVR_ARCHTARG).size

## Compile
$(AVR_OBJDIR)/lib/%.o: $(ROCKET_ROOT)/lib/%.c
	$(CC) $(AVR_CFLAGS) -c $< -o $@
$(AVR_OBJDIR)/app/%.o: %.c
	$(CC) $(AVR_CFLAGS) -c $< -o $@


## Objects that must be built in order to link.
AVR_LIB_OBJECTS := $(patsubst $(ROCKET_ROOT)/lib/%.c,$(AVR_OBJDIR)/lib/%.o, $(AVR_SOURCES))

$(AVR_LIB_FILE): $(AVR_LIB_OBJECTS)
	rm -f $@
	avr-ar r $@ $(AVR_LIB_OBJECTS)

# TARGET_OBJECTS comes from the app's Makefile
AVR_TARGET_OBJECTS := $(patsubst %.o,$(AVR_OBJDIR)/app/%.o, $(TARGET_OBJECTS))

##Link
$(AVR_ARCHTARG).elf: $(AVR_LIB_FILE) $(AVR_TARGET_OBJECTS)
	echo $(ALL_PLATFORM_SOURCES)
	$(CC) $(AVR_TARGET_OBJECTS) $(AVR_LDFLAGS) -o $@

$(AVR_ARCHTARG).hex: $(AVR_ARCHTARG).elf
	avr-objcopy -O ihex $(HEX_FLASH_FLAGS)  $< $@

$(AVR_ARCHTARG).eep: $(AVR_ARCHTARG).elf
	avr-objcopy $(HEX_EEPROM_FLAGS) -O ihex $< $@ || exit 0

$(AVR_ARCHTARG).lss: $(AVR_ARCHTARG).elf
	avr-objdump -h -S --syms $< > $@

.PHONY:
$(AVR_ARCHTARG).size: $(AVR_ARCHTARG).elf
	@echo
#	@avr-size -C --mcu=${MCU} $(AVR_ARCHTARG).elf
	avr-size $(AVR_ARCHTARG).elf

## Clean target
avr-clean:
	-rm -rf \
	    	$(AVR_OBJDIR) \
		$(AVR_ARCHTARG).elf \
		$(AVR_ARCHTARG).hex \
		$(AVR_ARCHTARG).eep \
		$(AVR_ARCHTARG).lss \
		$(AVR_ARCHTARG).map \


## Add automatically generated dependencies
DIR_LIST := $(sort $(dir $(AVR_LIB_OBJECTS) $(AVR_TARGET_OBJECTS)))
-include $(shell mkdir -p $(DIR_LIST)) $(foreach dir, $(DIR_LIST), $(wildcard $(dir)/*.d))

##############################################################################

ifeq ($(MCU),atmega8)
AVRCONFIG := 
AVROPTS := -p m8
endif

ifeq ($(MCU),atmega328p)
#AVROPTS := -p m328p
AVRCONFIG := /etc/avrdude.conf

#$(AVRCONFIG): /etc/avrdude.conf ../../avrdude-atmega328p.conf
#	cat $^ > $@

AVROPTS := -C $(AVRCONFIG) -p m328p
endif

ifeq ($(MCU),atmega1284p)
AVRCONFIG := 
AVROPTS := -p m1284p
endif

program: $(AVR_ARCHTARG).lss $(AVR_ARCHTARG).hex $(AVRCONFIG)
	sudo avrdude -c usbtiny $(AVROPTS) -u -U flash:w:$(AVR_ARCHTARG).hex

# Fuse byte documentation:
# page 223 of http://www.atmel.com/dyn/resources/prod_documents/doc2486.pdf
# CKSEL3..0 are the low nybble of lfuse. Internal values 1..4 (page 30)


readclock: $(AVRCONFIG)
	sudo avrdude -c usbtiny $(AVROPTS) -u -U lfuse:r:lfuse:h
	echo 'lfuse clock bits: ' `cat lfuse`

# TODO figure out clock constants for 328p
# Bummer, 328p only has 8MHz and 128kHz internal clocks.

setclock1mhz:
	$(ROCKET_ROOT)/avrclock.py atmega8 1
