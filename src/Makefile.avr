# Objects that should be part of the real hardware but
# not the simulator
AVR_ONLY_OBJECTS := \
	hardware.o

ARCHTARG := $(TARGET).$(MCU).$(BOARD)

# Compilation
AVR_OBJDIR = obj.avr.$(MCU).$(BOARD)
AVR_LIBNAME = rocket
AVR_LIB_FILE = $(AVR_OBJDIR)/lib$(AVR_LIBNAME).a
CC = avr-gcc

## Options common to compile, link and assembly rules
AVR_COMMON_FLAGS = -Wall -Werror -mmcu=$(MCU)

## Compile options common for all C compilation units.
AVR_CFLAGS = $(AVR_COMMON_FLAGS)
AVR_CFLAGS += -Wall -Werror -I$(ROCKET_ROOT)/include -I$(AVR_OBJDIR)
AVR_CFLAGS += -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
AVR_CFLAGS += -fdata-sections -ffunction-sections # Put all funcs/data in their own sections
AVR_CFLAGS += -MD -MP -MT $(AVR_OBJDIR)/$(*F).o -MF $(AVR_OBJDIR)/$(@F).d 
AVR_CFLAGS += -gdwarf-2 -std=gnu99 -Os 
AVR_CFLAGS += -DMCU$(MCU)=1 -DBOARD_$(BOARD)

## Assembly specific flags
ASMFLAGS = $(AVR_COMMON_FLAGS)
ASMFLAGS += $(AVR_CFLAGS)
ASMFLAGS += -x assembler-with-cpp -Wa,-gdwarf2

## Linker flags
AVR_LDFLAGS = $(AVR_COMMON_FLAGS)
AVR_LDFLAGS +=  -Wl,-Map=$(ARCHTARG).map -L$(AVR_OBJDIR) -l$(AVR_LIBNAME) 
AVR_LDFLAGS += -Wl,--gc-sections # Garbage-collect ununused functions


## Intel Hex file production flags
HEX_FLASH_FLAGS = -R .eeprom -R .fuse -R .lock -R .signature

HEX_EEPROM_FLAGS = -j .eeprom
HEX_EEPROM_FLAGS += --set-section-flags=.eeprom="alloc,load"
HEX_EEPROM_FLAGS += --change-section-lma .eeprom=0 --no-change-warnings


## Objects that must be built in order to link
AVR_LIB_OBJECTS := $(patsubst %.o,$(AVR_OBJDIR)/%.o,$(COMMON_OBJECTS) \
	$(AVR_ONLY_OBJECTS) )

AVR_TARGET_OBJECTS := $(patsubst %.o,$(AVR_OBJDIR)/%.o, \
	$(TARGET_OBJECTS))


# Make sure MCU is defined
.PHONY: mcu-defined-check
 
def-checks:
ifeq ($(MCU),)
	@echo "MCU must be defined in your local Makefile (atmega8, atmega328p)"
	@false
else
	@true
endif
ifeq ($(BOARD),)
	@echo "BOARD must be defined in your local Makefile (PCB10, PCB11, CUSTOM)"
	@false
else
	@true
endif

## Build
avr-all: def-checks $(ARCHTARG).elf $(ARCHTARG).hex $(ARCHTARG).eep $(ARCHTARG).lss $(ARCHTARG).size

## Compile
$(AVR_OBJDIR)/%.o: $(ROCKET_ROOT)/lib/%.c
	$(CC) $(AVR_CFLAGS) -c $< -o $@
$(AVR_OBJDIR)/%.o: %.c
	$(CC) $(AVR_CFLAGS) -c $< -o $@


##Build library (to avoid linking dead objects)
$(AVR_LIB_FILE): $(AVR_LIB_OBJECTS)
	rm -f $@
	ar r $@ $(AVR_LIB_OBJECTS)

##Link
$(ARCHTARG).elf: $(AVR_LIB_FILE) $(AVR_TARGET_OBJECTS)
	$(CC) $(AVR_TARGET_OBJECTS) $(AVR_LDFLAGS) -o $@

%.hex: %.elf
	avr-objcopy -O ihex $(HEX_FLASH_FLAGS)  $< $@

%.eep: %.elf
	avr-objcopy $(HEX_EEPROM_FLAGS) -O ihex $< $@ || exit 0

%.lss: %.elf
	avr-objdump -h -S $< > $@

.PHONY:
$(ARCHTARG).size: $(ARCHTARG).elf
	@echo
#	@avr-size -C --mcu=${MCU} $(ARCHTARG).elf
	avr-size $(ARCHTARG).elf

## Clean target
avr-clean:
	-rm -rf \
	    	$(AVR_OBJDIR)/* \
		$(ARCHTARG).elf \
		$(ARCHTARG).hex \
		$(ARCHTARG).eep \
		$(ARCHTARG).lss \
		$(ARCHTARG).map \


## Other dependencies
-include $(shell mkdir -p $(AVR_OBJDIR)) $(wildcard $(AVR_OBJDIR)/*.d)

##############################################################################

ifeq ($(MCU),atmega8)
AVRCONFIG := 
AVROPTS := -p m8
endif
ifeq ($(MCU),atmega328p)
#AVROPTS := -p m328p
AVRCONFIG := ../../avrdude+atmega328p.conf

$(AVRCONFIG): /etc/avrdude.conf ../../avrdude-atmega328p.conf
	cat $^ > $@

AVROPTS := -C $(AVRCONFIG) -p m328p
endif

program: $(ARCHTARG).hex
	sudo avrdude -c usbtiny $(AVROPTS) -u -U flash:w:$(ARCHTARG).hex

# Fuse byte documentation:
# page 223 of http://www.atmel.com/dyn/resources/prod_documents/doc2486.pdf
# CKSEL3..0 are the low nybble of lfuse. Internal values 1..4 (page 30)


readclock: $(AVRCONFIG)
	sudo avrdude -c usbtiny $(AVROPTS) -u -U lfuse:r:lfuse:h
	echo 'lfuse clock bits: ' `cat lfuse`

# TODO figure out clock constants for 328p
setclock1mhz:
	sudo avrdude -c usbtiny -p m8 -u -U lfuse:w:0xe1:m

setclock2mhz:
	sudo avrdude -c usbtiny -p m8 -u -U lfuse:w:0xe2:m

setclock4mhz:
	sudo avrdude -c usbtiny -p m8 -u -U lfuse:w:0xe3:m

setclock8mhz:
	sudo avrdude -c usbtiny -p m8 -u -U lfuse:w:0xe4:m


