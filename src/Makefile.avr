 #
 # This file is part of RulOS, Ravenna Ultra-Low-Altitude Operating
 # System -- the free, open-source operating system for microcontrollers.
 #
 # Written by Jon Howell (jonh@jonh.net) and Jeremy Elson (jelson@gmail.com),
 # May 2009.
 #
 # This operating system is in the public domain.  Copyright is waived.
 # All source code is completely free to use by anyone for any purpose
 # with no restrictions whatsoever.
 #
 # For more information about the project, see: www.jonh.net/rulos
 #

# Objects that should be part of the real hardware but
# not the simulator
AVR_ONLY_OBJECTS := \
	hardware.o \
	hardware_6matrix.o \
	hardware_adc.o \
	hardware_audio.o \
	hardware_keypad.o \
	hardware_rocketpanel.o \
	hardware_timers.o \
	hardware_uart.o \

AVR_ROCKET_OBJECTS := \
	hardware_spi.o \
	pov.o \
	tilty_input.o \

ifndef CORE_ONLY
	AVR_ONLY_OBJECTS += $(AVR_ROCKET_OBJECTS)
endif

ifndef NO_TWI
	AVR_ONLY_OBJECTS += hardware_twi.o
endif

ifeq ($(MCU),atmega1284p)
AVR_ONLY_OBJECTS += hardware_graphic_lcd_12232.o
endif

BSS_CANARY_OBJECT := bss_canary.o

# NB pov, tilty_input are parts of magic wand project; never compiled SIM.
# a bit sloppy.

ARCHTARG := $(TARGET).$(MCU).$(BOARD)

# Compilation
AVR_OBJDIR = obj.avr.$(MCU).$(BOARD)
AVR_LIBNAME = rocket
AVR_LIB_FILE = $(AVR_OBJDIR)/lib$(AVR_LIBNAME).a
CC = avr-gcc

## Options common to compile, link and assembly rules
AVR_COMMON_FLAGS = -Wall -Werror -mmcu=$(MCU)

## Compile options common for all C compilation units.
AVR_CFLAGS = $(AVR_COMMON_FLAGS)
AVR_CFLAGS += -Wall -Werror -I$(ROCKET_ROOT)/include -I$(AVR_OBJDIR)
AVR_CFLAGS += -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums
AVR_CFLAGS += -fdata-sections -ffunction-sections # Put all funcs/data in their own sections
AVR_CFLAGS += -MD -MP -MT $(AVR_OBJDIR)/$(*F).o -MF $(AVR_OBJDIR)/$(@F).d 
AVR_CFLAGS += -gdwarf-2 -std=gnu99 -Os 
AVR_CFLAGS += -DMCU$(MCU)=1 -DBOARD_$(BOARD)
AVR_CFLAGS += $(EXTRA_AVR_CFLAGS)


## Assembly specific flags
ASMFLAGS = $(AVR_COMMON_FLAGS)
ASMFLAGS += $(AVR_CFLAGS)
ASMFLAGS += -x assembler-with-cpp -Wa,-gdwarf2

## Linker flags
AVR_LDFLAGS = $(AVR_COMMON_FLAGS)
AVR_LDFLAGS +=  -Wl,-Map=$(ARCHTARG).map -L$(AVR_OBJDIR) -l$(AVR_LIBNAME) 
AVR_LDFLAGS += -Wl,--gc-sections # Garbage-collect ununused functions
AVR_LDFLAGS += $(EXTRA_AVR_LDFLAGS)


## Intel Hex file production flags
HEX_FLASH_FLAGS = -R .eeprom -R .fuse -R .lock -R .signature

HEX_EEPROM_FLAGS = -j .eeprom
HEX_EEPROM_FLAGS += --set-section-flags=.eeprom="alloc,load"
HEX_EEPROM_FLAGS += --change-section-lma .eeprom=0 --no-change-warnings

# Make sure MCU is defined
.PHONY: mcu-defined-check
 
def-checks:
ifeq ($(MCU),)
	@echo "MCU must be defined in your local Makefile (atmega8, atmega328p)"
	@false
else
	@true
endif
ifeq ($(BOARD),)
	@echo "BOARD must be defined in your local Makefile (PCB10, PCB11, CUSTOM)"
	@false
else
	@true
endif

## Build
avr-all: def-checks $(ARCHTARG).elf $(ARCHTARG).hex $(ARCHTARG).eep $(ARCHTARG).lss $(ARCHTARG).size

## Compile
$(AVR_OBJDIR)/%.o: $(ROCKET_ROOT)/lib/%.c
	$(CC) $(AVR_CFLAGS) -c $< -o $@
$(AVR_OBJDIR)/%.o: %.c
	$(CC) $(AVR_CFLAGS) -c $< -o $@


## Objects that must be built in order to link.  Note: bss_canary
## must be last
AVR_LIB_OBJECTS := $(patsubst %.o,$(AVR_OBJDIR)/%.o,$(COMMON_OBJECTS) \
	$(AVR_ONLY_OBJECTS) $(BSS_CANARY_OBJECT) )

$(AVR_LIB_FILE): $(AVR_LIB_OBJECTS)
	rm -f $@
	avr-ar r $@ $(AVR_LIB_OBJECTS)

##Link
AVR_TARGET_OBJECTS := $(patsubst %.o,$(AVR_OBJDIR)/%.o, \
	$(TARGET_OBJECTS))

$(ARCHTARG).elf: $(AVR_LIB_FILE) $(AVR_TARGET_OBJECTS)
	$(CC) $(AVR_TARGET_OBJECTS) $(AVR_LDFLAGS) -o $@

%.hex: %.elf
	avr-objcopy -O ihex $(HEX_FLASH_FLAGS)  $< $@

%.eep: %.elf
	avr-objcopy $(HEX_EEPROM_FLAGS) -O ihex $< $@ || exit 0

%.lss: %.elf
	avr-objdump -h -S --syms $< > $@

.PHONY:
$(ARCHTARG).size: $(ARCHTARG).elf
	@echo
#	@avr-size -C --mcu=${MCU} $(ARCHTARG).elf
	avr-size $(ARCHTARG).elf

## Clean target
avr-clean:
	-rm -rf \
	    	$(AVR_OBJDIR)/* \
		$(ARCHTARG).elf \
		$(ARCHTARG).hex \
		$(ARCHTARG).eep \
		$(ARCHTARG).lss \
		$(ARCHTARG).map \


## Other dependencies
-include $(shell mkdir -p $(AVR_OBJDIR)) $(wildcard $(AVR_OBJDIR)/*.d)

##############################################################################

ifeq ($(MCU),atmega8)
AVRCONFIG := 
AVROPTS := -p m8
endif

ifeq ($(MCU),atmega328p)
#AVROPTS := -p m328p
AVRCONFIG := /etc/avrdude.conf

#$(AVRCONFIG): /etc/avrdude.conf ../../avrdude-atmega328p.conf
#	cat $^ > $@

AVROPTS := -C $(AVRCONFIG) -p m328p
endif

ifeq ($(MCU),atmega1284p)
AVRCONFIG := 
AVROPTS := -p m1284p
endif

program: $(ARCHTARG).lss $(ARCHTARG).hex $(AVRCONFIG)
	sudo avrdude -c usbtiny $(AVROPTS) -u -U flash:w:$(ARCHTARG).hex

# Fuse byte documentation:
# page 223 of http://www.atmel.com/dyn/resources/prod_documents/doc2486.pdf
# CKSEL3..0 are the low nybble of lfuse. Internal values 1..4 (page 30)


readclock: $(AVRCONFIG)
	sudo avrdude -c usbtiny $(AVROPTS) -u -U lfuse:r:lfuse:h
	echo 'lfuse clock bits: ' `cat lfuse`

# TODO figure out clock constants for 328p
# Bummer, 328p only has 8MHz and 128kHz internal clocks.

setclock1mhz:
	$(ROCKET_ROOT)/avrclock.py atmega8 1
